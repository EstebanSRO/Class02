# -*- coding: utf-8 -*-
"""proyecto mineria 0.3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1naSCL4NLon5jZOx02SCK8VegBdSQXOPZ

Conexiones a base de datos y librerias
"""

from google.colab import drive
drive.mount('/content/drive')

#Establececemos conexion con el documento
Path = '/content/drive/MyDrive/Proyecto Final Mineria/Challenge_4y5.csv'

#Importamos todas las librerias que nos pueden ser de utilidad
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib as mpl
import plotly
import plotly.express as px
from sklearn.decomposition import PCA
from sklearn import preprocessing
from scipy import stats
from sklearn.cluster import KMeans

"""# hi


hi [google.com](hi)
"""

#Visualizamos la estructura de la base de datos
df = pd.read_csv(Path)
df

"""descripcion de base de datos """

#Visualizamos como esta compuestas las columnas
df.columns

#Establecemos la tabla pivote para hacer la suma de los productos individualmente hablando entre las semanas
pd.pivot_table(df,
               index = 'Producto',
               values= ['sem41', 'sem42','sem43','sem44'],
               aggfunc='sum')

#Si queremos agregar una columna adicional que contenga la clasificación de cada producto, primero debemos crear una lista con la clasificación correspondiente para cada producto. 
#Y para ello, Ordenamos todos los productos como categorias para poder establecer la canibalización posteriormente hablando
categorias = {
    'Agua': ['AGUA MINERAL FAMILIAR', 'AGUA MINERAL INDIVIDUAL', 'AGUA PURIFICADA FAMILIAR',
             'AGUA PURIFICADA INDIVIDUAL', 'AGUA SABORIZADA INDIVIDUAL'],
    'Bebidas': ['BEBIDAS DE SOYA FAMILIAR', 'BEBIDAS DE SOYA INDIVIDUAL', 'BEBIDAS ENERGETICAS',
                'BEBIDAS INFANTILES', 'BEBIDAS REFRESCANTES'],
    'Cocas': ['COLAS LIGHT FAMILIAR', 'COLAS LIGHT INDIVIDUAL', 'COLAS REGULAR FAMILIAR NO RETORNABLE',
              'COLAS REGULAR FAMILIAR RETORNABLE', 'COLAS REGULAR INDIVIDUAL NO RETORNABLE',
              'COLAS REGULAR INDIVIDUAL RETORNABLE'],
    'Isotónicos': ['ISOTONICOS'],
    'Jugos': ['JUGOS Y NECTARES HOGAR', 'NARANJADAS'],
    'Leche': ['LECHE UHT ESPECIALIZADA', 'LECHE UHT REGULAR', 'LECHE UHT SABORIZADA'],
    'Refrescos': ['SABORES REGULAR FAMILIAR NO RETORNABLE', 'SABORES REGULAR FAMILIAR RETORNABLE',
                  'SABORES REGULAR INDIVIDUAL NO RETORNABLE', 'SABORES REGULAR INDIVIDUAL RETORNABLE'],
    'Te': ['TE']
}

#Recorrimos cada categoría del diccionario categorias anteriormente establecido para:
#Permitir asignar a cada producto de la base de datos la categoría correspondiente utilizando la lógica definido. 
#verificar si el producto x está en la lista de productos de esa categoría. 
#Si lo encuentra, retorna el nombre de la categoría. Si no encuentra ninguna coincidencia, retorna "Otro".
def custom_cs(x):
    for cat, prods in categorias.items():
        if x in prods:
            return cat

#La funcion append() nos ayuda para agregar la fila a la base de datos
#El parametro ignore_index=True es para que la nueva fila se agregue al final de la base de datos y se le asigne un nuevo índice numérico en lugar de usar uno existente.
df = df.append(categorias, ignore_index=True)

#La función custom_cs nos ayuda a tomar cada elemento de la columna "producto" y lo clasifica según las categorías definidas en categorias. 
#La función map aplica a cada elemento de la columna "producto" y devuelve una serie con la categoría correspondiente a cada de ellas.
clasificacion = df['Producto'].map(custom_cs)

#Asignamos la serie clasificacion como una nueva columna llamada 'clasificacion' en un DataFrame df.
df['clasificacion'] = clasificacion

#Por fin, queda listo nuestra pivot_table donde trabajaremos ahora en adelante con estos datos estructurados.
pd.pivot_table(df,
               index = ['Producto','clasificacion'],
               values= ['sem41', 'sem42','sem43','sem44'],
               aggfunc='sum')

#Definimos Pv
Pv = pd.pivot_table(df,
                       index=['Producto', 'clasificacion'],
                       values=['sem41', 'sem42', 'sem43', 'sem44'],
                       aggfunc='sum')
# Calcula las métricas de ventas canabalizadas, ventas de transferencias, tasa de canibalizacion y Tasa de transferencia
Pv['Total ventas'] = Pv.sum(axis=1)
Pv['Ventas canibalizadas'] = Pv.groupby('clasificacion')['Total ventas'].apply(lambda x: x - x.shift(1, fill_value=0))
Pv['Ventas transferidas'] = Pv.groupby('clasificacion')['Total ventas'].apply(lambda x: x.shift(-1, fill_value=0) - x)
Pv['Tasa de canibalización'] = Pv['Ventas canibalizadas'] / Pv['Total ventas'].shift(1, fill_value=0)
Pv['Tasa de transferencia'] = Pv['Ventas transferidas'] / Pv['Total ventas']

# Tabla pivot con métricas calculadas
tabla_pivot = pd.pivot_table(df,
               index = ['Producto','clasificacion'],
               values= ['sem41', 'sem42','sem43','sem44'],
               aggfunc='sum')

# Calcula las métricas de canibalización y transferencia
canibalizacion = tabla_pivot.apply(lambda row: row / row.sum(), axis=1)
transferencia = tabla_pivot.apply(lambda col: col / col.sum(), axis=0)

# Imprime las tablas de métricas
print("Tasa de canibalización:")
display(canibalizacion.style.format("{:.2%}"))

print("Tasa de transferencia:")
display(transferencia.style.format("{:.2%}"))

# Tabla pivot con métricas calculadas y agrupada por clasificación
tabla_pivot = pd.pivot_table(df,
                             index=['clasificacion', 'Producto'],
                             values=['sem41', 'sem42', 'sem43', 'sem44'],
                             aggfunc='sum')

# Calcula las métricas de canibalización y transferencia
canibalizacion = tabla_pivot.apply(lambda row: row / row.sum(), axis=1)
transferencia = tabla_pivot.apply(lambda col: col / col.sum(), axis=0)

# Imprime las tablas de métricas
print("Tasa de canibalización:")
display(canibalizacion.style.format("{:.2%}"))

print("Tasa de transferencia:")
display(transferencia.style.format("{:.2%}"))

# Tabla pivot con métricas calculadas y agrupada por clasificación
tabla_pivot = pd.pivot_table(df,
                             index=['clasificacion'],
                             values=['sem41', 'sem42', 'sem43', 'sem44'],
                             aggfunc='sum')

# Calcula las métricas de canibalización y transferencia
canibalizacion = tabla_pivot.apply(lambda row: row / row.sum(), axis=1)
transferencia = tabla_pivot.apply(lambda col: col / col.sum(), axis=0)

# Imprime las tablas de métricas
print("Tasa de canibalización:")
display(canibalizacion.style.format("{:.2%}"))

print("Tasa de transferencia:")
display(transferencia.style.format("{:.2%}"))

#Gráfico de barras apiladas de las ventas por semana por clasificación de producto.
ax = tabla_pivot.plot(kind='bar', stacked=True)
ax.set_ylabel('Ventas')
ax.set_title('Ventas por semana y clasificación de producto')
plt.show()

#Gráfico de barras de la tasa de canibalización por clasificación de producto.
ad = canibalizacion.plot(kind='bar')
ad.set_ylabel('Tasa de canibalización')
ad.set_title('Tasa de canibalización por clasificación de producto')
plt.show()

#Gráfico de línea de la evolución de las ventas por semana para cada clasificación de producto.
ap = tabla_pivot.plot(kind='line')
ap.set_ylabel('Ventas')
ap.set_title('Evolución de las ventas por semana para cada clasificación de producto')
plt.show()

#Gráfico de barras de la suma total de las ventas por clasificación de producto.
ak = tabla_pivot.plot(kind='bar')
ak.set_ylabel('Ventas')
ak.set_title('Suma total de las ventas por clasificación de producto')
plt.show()

#Gráfico de barras de la tasa de canibalización promedio por clasificación de producto.
ar = canibalizacion.mean().plot(kind='bar')
ar.set_ylabel('Tasa de canibalización promedio')
ar.set_title('Tasa de canibalización promedio por clasificación de producto')
plt.show()

# Crea una figura y un eje
fig, ax = plt.subplots()

# Crea un gráfico de línea para cada clasificación
for clasif in canibalizacion.index:
    ax.plot(canibalizacion.loc[clasif], label=clasif)

# Añade un título y etiquetas de los ejes
ax.set_title("Tasa de canibalización por clasificación")
ax.set_xlabel("Semana")
ax.set_ylabel("Tasa de canibalización")

# Añade una leyenda
ax.legend()

# Muestra el gráfico
plt.show()

"""............"""

!pip install jedi

!pip install streamlit

! pip install pyngrok

import streamlit as st

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py 
# import streamlit as st
# 
# #st.title("Tegcn0 MTY")
# #st.header("Esteban SR")

def page1():
    st.title("Página 1")
    
    # Agregamos una imagen
    st.image("https://picsum.photos/200")
    
    # Agregamos una tabla
    data = {'Nombre': ['Juan', 'María', 'Pedro', 'Luis'],
            'Edad': [23, 28, 31, 25],
            'Ciudad': ['Bogotá', 'Medellín', 'Cali', 'Barranquilla']}
    df = pd.DataFrame(data)
    st.write(df)

# Segunda página
def page2():
    st.title("Página 2")
    
    # Agregamos una imagen
    st.image("https://picsum.photos/300")
    
    # Agregamos un gráfico
    x = np.arange(0, 10, 0.1)
    y = np.sin(x)
    fig, ax = plt.subplots()
    ax.plot(x, y)
    ax.set_xlabel('x')
    ax.set_ylabel('sin(x)')
    ax.set_title('Gráfico de la función seno')
    st.pyplot(fig)

# Tercera página
def page3():
    st.title("Página 3")
    
    # Agregamos una imagen
    st.image("https://picsum.photos/400")
    
    # Agregamos una tabla
    data = {'Ciudad': ['Bogotá', 'Medellín', 'Cali', 'Barranquilla'],
            'Población': [7102602, 2424444, 2376411, 1239800],
            'Área': [1775, 382, 621, 1819]}
    df = pd.DataFrame(data)
    st.write(df)

# Definimos las páginas y el menú
pages = {
    "Página 1": page1,
    "Página 2": page2,
    "Página 3": page3
}

st.sidebar.title("Menú")
selection = st.sidebar.radio("Ir a", list(pages.keys()))

# Mostramos la página seleccionada
page = pages[selection]
page()

!streamlit run /usr/local/lib/python3.8/dist-packages/ipykernel_launcher.py [proyecto mineria 0.3.py]

! streamlit run app.py &>/dev/null&

! wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip

get_ipython ().system_raw('./ngrok http 8501 &')

!curl -s http://localhost:8501/api/tunnels | python3 -c "import sys, json; print(json.load(sys.stdin)['tunnels'][0]['public_url'])"

!npx localtunnel --port 8501